      subroutine l2appr ( t, n, k, q, diag, bcoef )
!  from  * a practical guide to splines *  by c. de boor
!  to be called in main program  l 2 m a i n .
!alls subprograms  bsplvb, bchfac/slv
!
!onstructs the (weighted discrete) l2-approximation by splines of order
!  k  with knot sequence  t(1), ..., t(n+k)  to given data points
!  ( tau(i), gtau(i) ), i=1,...,ntau. the b-spline coefficients
!  b c o e f   of the approximating spline are determined from the
!  normal equations using cholesky's method.
!
!******  i n p u t  ******
!  t(1), ..., t(n+k)  the knot sequence
!  n.....the dimension of the space of splines of order k with knots t.
!  k.....the order
!
!  w a r n i n g  . . .  the restriction   k .le. kmax (= 20)   is impo-
!        sed by the arbitrary dimension statement for  biatx  below, but
!        is  n o w h e r e   c h e c k e d   for.
!
!******  w o r k  a r r a y s  ******
!  q....a work array of size (at least) k*n. its first  k  rows are used
!       for the  k  lower diagonals of the gramian matrix  c .
!  diag.....a work array of length  n  used in bchfac .
!
!******  i n p u t  via  c o m m o n  /data/  ******
!  ntau.....number of data points
!  (tau(i),gtau(i)), i=1,...,ntau     are the  ntau  data points to be
!        fitted .
!  weight(i), i=1,...,ntau    are the corresponding weights .
!
!******  o u t p u t  ******
!  bcoef(1), ..., bcoef(n)  the b-spline coeffs. of the l2-appr.
!
!******  m e t h o d  ******
!  the b-spline coefficients of the l2-appr. are determined as the sol-
!  ution of the normal equations
!     sum ( (b(i),b(j))*bcoef(j) : j=1,...,n)  = (b(i),g),
!                                               i = 1, ..., n .
!  here,  b(i)  denotes the i-th b-spline,  g  denotes the function to
!  be approximated, and the  i n n e r   p r o d u c t  of two funct-
!  ions  f  and  g  is given by
!      (f,g)  :=  sum ( f(tau(i))*g(tau(i))*weight(i) : i=1,...,ntau) .
!  the arrays  t a u  and  w e i g h t  are given in common block
!   d a t a , as is the array  g t a u  containing the sequence
!  g(tau(i)), i=1,...,ntau.
!  the relevant function values of the b-splines  b(i), i=1,...,n, are
!  supplied by the subprogram  b s p l v b .
!     the coeff.matrix  c , with
!           c(i,j)  :=  (b(i), b(j)), i,j=1,...,n,
!  of the normal equations is symmetric and (2*k-1)-banded, therefore
!  can be specified by giving its k bands at or below the diagonal. for
!  i=1,...,n,  we store
!   (b(i),b(j))  =  c(i,j)  in  q(i-j+1,j), j=i,...,min0(i+k-1,n)
!  and the right side
!   (b(i), g )  in  bcoef(i) .
!  since b-spline values are most efficiently generated by finding sim-
!  ultaneously the value of  e v e r y  nonzero b-spline at one point,
!  the entries of  c  (i.e., of  q ), are generated by computing, for
!  each ll, all the terms involving  tau(ll)  simultaneously and adding
!  them to all relevant entries.
!
  implicit none
      integer k,n,   i,j,jj,kmax,left,leftmk,ll,mm,ntau,ntmax
      parameter (kmax=20,ntmax=200)
      real(8) bcoef(n),diag(n),q(k,n),t(n+k),  biatx(kmax),dw,gtau,tau,weig
      common / data / ntau, tau(ntmax),gtau(ntmax),weight(ntmax)
!
      do 7 j=1,n
         bcoef(j) = 0.
         do 7 i=1,k
    7       q(i,j) = 0.
      left = k
      leftmk = 0
      do 20 ll=1,ntau
!                   locate  l e f t  s.t. tau(ll) in (t(left),t(left+1))
   10       if (left .eq. n)            go to 15
            if (tau(ll) .lt. t(left+1)) go to 15
            left = left+1
            leftmk = leftmk + 1
                                        go to 10
   15    call bsplvb ( t, k, 1, tau(ll), left, biatx )
!        biatx(mm) contains the value of b(left-k+mm) at tau(ll).
!        hence, with  dw := biatx(mm)*weight(ll), the number dw*gtau(ll)
!        is a summand in the inner product
!           (b(left-k+mm), g)  which goes into  bcoef(left-k+mm)
!        and the number biatx(jj)*dw is a summand in the inner product
!           (b(left-k+jj), b(left-k+mm)), into  q(jj-mm+1,left-k+mm)
!        since  (left-k+jj) - (left-k+mm) + 1  =  jj - mm + 1 .
         do 20 mm=1,k
            dw = biatx(mm)*weight(ll)
            j = leftmk + mm
            bcoef(j) = dw*gtau(ll) + bcoef(j)
            i = 1
            do 20 jj=mm,k
               q(i,j) = biatx(jj)*dw + q(i,j)
   20          i = i + 1
!
!             construct cholesky factorization for  c  in  q , then use
!             it to solve the normal equations
!                    c*x  =  bcoef
!             for  x , and store  x  in  bcoef .
      call bchfac ( q, k, n, diag )
      call bchslv ( q, k, n, bcoef )
                                        return
      end subroutine l2appr
